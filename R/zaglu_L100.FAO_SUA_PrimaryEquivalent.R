# Copyright 2019 Battelle Memorial Institute; see the LICENSE file.

#' module_aglu_L100.FAO_SUA_PrimaryEquivalent
#'
#' Generate supply utilization balance in primary equivalent
#'
#' @param command API command to execute
#' @param ... other optional parameters, depending on command
#' @return Depends on \code{command}: either a vector of required inputs, a vector of output names, or (if
#'   \code{command} is "MAKE") all the generated outputs: \code{GCAM_AgLU_SUA_APE_1973_2019},
#'   \code{FAO_AgProd_Kt_All},\code{FAO_AgArea_Kha_All},\code{FAO_Food_Macronutrient_All_2010_2019},
#'   \code{FAO_Food_MacronutrientRate_2010_2019_MaxValue}
#' @details This chunk compiles balanced supply utilization data in primary equivalent in GCAM region and commodities.
#' A method to generate primary equivalent is created for the new FAOSTAT supply utilization data (2010 to 2019).
#' New SUA balance is connected to the old one (before 2010). Production and harvested area data with FAO region and item
#' for primary production are provided. For FAO food items, macronutrient values are calculated at SUA item level.
#' Data processing was consistent across scales. Note that GCAM regions and commodities in aggregation mapping can
#' be changed in corresponding mappings. The output data is not averaged over time.
#' @importFrom assertthat assert_that
#' @importFrom dplyr summarize bind_rows filter if_else inner_join left_join mutate rename select n group_by_at
#' first case_when vars
#' @importFrom tibble tibble is_tibble
#' @importFrom tidyr complete drop_na gather nesting spread replace_na
#' @author XZ 2022
module_aglu_L100.FAO_SUA_PrimaryEquivalent <- function(command, ...) {

  MODULE_INPUTS <-
    c(FILE = "aglu/AGLU_ctry",
      FILE = "common/iso_GCAM_regID",
      FILE = "common/GCAM_region_names",
      FILE = "aglu/FAO/GCAMFAOSTAT_SUA",
      FILE = "aglu/FAO/GCAMFAOSTAT_BiTrade",
      FILE = "aglu/FAO/Mapping_SUA_PrimaryEquivalent",
      FILE = "aglu/FAO/SUA_item_code_map",
      FILE = "aglu/FAO/GCAMFAOSTAT_NonFodderProdArea",
      FILE = "aglu/FAO/GCAMFAOSTAT_FBSH_CB",
      FILE = "aglu/FAO/Mapping_item_FBS_GCAM",
      FILE = "aglu/FAO/GCAMFAOSTAT_FodderProdArea",
      FILE = "aglu/FAO/FAO_ag_items_PRODSTAT",
      FILE = "aglu/FAO/FAO_an_items_PRODSTAT",
      FILE = "aglu/FAO/GCAMFAOSTAT_MacroNutrientRate")

  MODULE_OUTPUTS <-
    c("GCAM_AgLU_SUA_APE_1973_2019",
      "FAO_AgProd_Kt_All",
      "FAO_AgArea_Kha_All",
      "FAO_Food_Macronutrient_All_2010_2019",
      "FAO_Food_MacronutrientRate_2010_2019_MaxValue")

  if(command == driver.DECLARE_INPUTS) {
    return(MODULE_INPUTS)
  } else if(command == driver.DECLARE_OUTPUTS) {
    return(MODULE_OUTPUTS)
  } else if(command == driver.MAKE) {

    year <- value <- Year <- Value <- FAO_country <- iso <- NULL    # silence package check.
    Mapping_item_FBS_GCAM <- GCAM_commodity <- region <- element <- source_primary <-
      source_item <- Prod_diff <- Processed <- `Stock Variation` <- Production <-
      Import <- Export <- Food <- Feed <- `Other uses` <- `Regional supply` <-
      `Regional demand` <- item <- GCAM_subsector <- GCAM_subsector <-  CropMeat <-
      FAO_an_items_PRODSTAT <-
      macronutrient <- macronutrient_value <- calperg <- proteinperc <-
      macronutrient_value_World <- Food_Kt <- area_code <- area <- AGLU_ctry <-
      iso_GCAM_regID <- GCAM_region_ID <- GCAM_region_names <-  NULL

    all_data <- list(...)[[1]]

    # Load required inputs ----

    get_data_list(all_data, MODULE_INPUTS, strip_attributes = TRUE)

    # Get Supply-utilization account (SUA) elements and use as factor
    All_Bal_element <- levels(GCAMFAOSTAT_SUA$element)
    All_Bal_element <- factor(All_Bal_element, levels = All_Bal_element)

    # Bilateral trade item indicator is added to SUA_item_code_map
    # filter GCAMFAOSTAT_BiTrade to only include bilateral trade item to be
    # consistent with GCAMFAOSTAT_SUA
    BilaterialTrade_ItemCode <- SUA_item_code_map %>% filter(TM == TRUE) %>% distinct(item_code) %>% pull
    GCAMFAOSTAT_BiTrade %>%
      filter(item_code %in% BilaterialTrade_ItemCode) ->
      GCAMFAOSTAT_BiTrade
    SUA_item_code_map %>% select(item, item_code) -> SUA_item_code_map

    # Section1: [2010-2019] Region aggregation of supply-utilization-accounting data ----

    # Note: the volume of data in this processing is quite large.  Therefore we took
    # extra care to be cognizant of processing speed and memory usage through section 1 and 2.
    # In particular we rely on ID codes and factors are much as possible to speed up joins.
    # In addition, we have filtered zero rows from the raw data to significantly reduce
    # the overall volume.  Unfortunately, this change makes the processing riddled with
    # trap doors where we need to be extra careful to complete / refill zeros or risk loosing
    # rows of legitimate data.

    # create a complete area / iso / GCAM region mapping
    GCAMFAOSTAT_NonFodderProdArea %>%
      select(area_code, area) %>%
      distinct() %>%
      left_join_error_no_match(AGLU_ctry %>% distinct(area_code = FAO_country_code, iso), by = c("area_code")) %>%
      left_join_error_no_match(iso_GCAM_regID %>% select(iso, GCAM_region_ID), by = "iso") %>%
      left_join_error_no_match(GCAM_region_names, by = "GCAM_region_ID") ->
      Area_Region_Map

    # 1.1 Regional aggregation for SUA ----

    # Aggregate SUA to GCAM regions
    # Intra regional trade is removed when bilateral trade data is available

    GCAMFAOSTAT_SUA %>%
      left_join_error_no_match(Area_Region_Map %>% select(area_code, GCAM_region_ID), by="area_code") %>%
      group_by(GCAM_region_ID, item_code, element, year) %>%
      summarize(value = sum(value), .groups = "drop") %>%
      ungroup() ->
      DF_SUA_Agg

    # Calculate intra regional trade
    GCAMFAOSTAT_BiTrade %>%
      left_join_error_no_match(Area_Region_Map %>% select(area_code, GCAM_region_ID), by="area_code") %>%
      left_join_error_no_match(Area_Region_Map %>% select(source_code = area_code, source_GCAM_region_ID = GCAM_region_ID), by="source_code") %>%
      filter(GCAM_region_ID == source_GCAM_region_ID) %>%
      group_by(GCAM_region_ID, item_code, year) %>%
      summarize(value = sum(value), .groups = "drop") %>%
      ungroup() %>%
      mutate(value = -value) ->
      DF_INTRA_REG_TRADE

    # SUA has fewer items and years than the bilateral data set and in addition
    # there are some small discrepancies zero import/export in SUA vs tiny amounts of trade
    # in the bilateral.  Doing a left_join here will drop these dependencies which is
    # what we want.
    bind_rows(DF_INTRA_REG_TRADE %>% mutate(element = All_Bal_element[All_Bal_element == "Export"]),
              DF_INTRA_REG_TRADE %>% mutate(element = All_Bal_element[All_Bal_element == "Import"])) %>%
      rename(TCL = value) %>%
      right_join(DF_SUA_Agg, by = c("GCAM_region_ID", "item_code", "year", "element")) %>%
      # equivalent to
      #left_join(DF_SUA_Agg, ., by=c("GCAM_region_ID", "item_code", "year", "element")) %>%
      mutate(value = if_else(is.na(TCL), value, value + TCL)) %>%
      select(-TCL) %>%
      filter(value != 0.0) ->
      DF_SUA_Agg_TradeAdj


    # need to remove gross trade when export > production
    # to maintain triangle the inequality rule
    # Note that Prod < export is still possible due to "residuals"
    DF_SUA_Agg_TradeAdj %>%
      filter(element %in% c("Production", "Import", "Export")) %>%
      spread(element, value, fill = 0.0) %>%
      mutate(value = pmax(Production - Export, -Import)) %>%
      filter(value < 0) %>%
      select(-Production, -Import, -Export) ->
      GrossTradeRM

    bind_rows(GrossTradeRM %>% mutate(element = All_Bal_element[All_Bal_element == "Export"]),
              GrossTradeRM %>% mutate(element = All_Bal_element[All_Bal_element == "Import"]),
              DF_SUA_Agg_TradeAdj) %>%
      group_by(GCAM_region_ID, item_code, element, year) %>%
      summarize(value = sum(value), .groups = "drop") %>%
      ungroup() ->
      FAO_SUA_Kt_2010to2019_R


    Min_SUA_Year <- min(FAO_SUA_Kt_2010to2019_R$year)
    FAO_SUA_Kt_2010to2019 <- GCAMFAOSTAT_SUA
    ## Clean up
    rm(GCAMFAOSTAT_SUA)
    rm(GCAMFAOSTAT_BiTrade)
    ## Done Section1 ----
    #****************************----

    # Section2: [2010-2019] Primary equivalent aggregation to GCAM commodities ----

    Mapping_SUA_PrimaryEquivalent %>%
      left_join_error_no_match(SUA_item_code_map %>% rename(sink_item_code = item_code), by=c("sink_item" = "item")) %>%
      left_join_error_no_match(SUA_item_code_map %>% rename(source_item_code = item_code), by=c("source_item" = "item")) %>%
      mutate(APE_comm = as.factor(APE_comm)) ->
      Mapping_SUA_PrimaryEquivalent_ID

    #Mapping_SUA_PrimaryEquivalent_ID[Mapping_SUA_PrimaryEquivalent_ID$sink_item_code == 235, "source_primary"] = FALSE

    Mapping_SUA_PrimaryEquivalent_ID %>%
      select(item_code = sink_item_code, output_specific_extraction_rate) %>%
      filter(!is.na(output_specific_extraction_rate)) ->
      OUTPUT_SPECIFIC_EXTRACTION_RATE

    # 2.1 Helper functions for SUA primary equivalent aggregation ----


    # Get extraction rate
    # @description Gross extraction rate is calculated for domestic, traded, and lagged values.
    # By gross, it means sink items are aggregated.
    # The function is used in Proc_primarize.
    # @param DF_CURR_NEST Input supply-utilization accounting data frame with one tier of processing
    # @param DF_ALL Input supply-utilization accounting data frame with ALL the data
    # @return A data frame including regional, traded, and world extraction rates of a processing

    Get_GROSS_EXTRACTION_RATE <- function(DF_CURR_NEST, DF_ALL) {
      curr_sink_items = unique(DF_CURR_NEST$item_code)
      Mapping_SUA_PrimaryEquivalent_ID %>%
        filter(sink_item_code %in% curr_sink_items) ->
        Curr_Sink_Mapping
      curr_source_items = unique(Curr_Sink_Mapping$source_item_code)
      Mapping_SUA_PrimaryEquivalent_ID %>%
        filter(source_item_code %in% curr_source_items) ->
        Curr_Source_Mapping
      Curr_Source_Mapping %>%
        group_by(APE_comm) %>%
        mutate(minimium_extraction_rate = if_else(Q25asMin, extraction_rate_Q25, 0)) %>%
        select(APE_comm, minimium_extraction_rate) %>%
        distinct() ->
        MIN_EXTRACTION_RATE

      DF_ALL %>%
        #Prepare data to calculate regional, traded, and world average extraction rates
        tidyr::unnest(c(data)) %>%
        filter(element == "Processed", item_code %in% curr_source_items) %>%
        select(-nest_level) %>%
        bind_rows(DF_CURR_NEST %>% filter(element == "Production" | element == "Export")) %>%
        dplyr::group_by_at(vars(-item_code, -value)) %>%
        summarize(value=sum(value), .groups = "drop") %>%
        ungroup() %>%
        complete(GCAM_region_ID = GCAM_region_names$GCAM_region_ID, nesting(element, year, APE_comm), fill=list(value=0)) %>%
        spread(element, value, fill = 0.0) %>%
        left_join_error_no_match(MIN_EXTRACTION_RATE, by=c("APE_comm")) %>%
        group_by(APE_comm, year) %>%
        mutate(extraction_rate_world = sum(Production) / sum(Processed),
               # in case sum(Processed) or sum(Production) == 0
               extraction_rate_world = if_else(extraction_rate_world != 0 & is.finite(extraction_rate_world),
                                               extraction_rate_world, 1),
               extraction_rate = Production / Processed,
               # Regional extraction rate = prod of an aggregated processed item  / Processed use of an aggregated primary item
               # Use world average to fill in NA or zero
               extraction_rate = if_else(is.na(extraction_rate) | extraction_rate == 0, extraction_rate_world, extraction_rate),
               # Using minimum extraction rate here as an upper threshold to avoid extremely large scaling later
               extraction_rate = pmax(extraction_rate, minimium_extraction_rate),
               # Set rate to Inf when Processed == 0
               PositiveProd_ZeroProc = Production > 0 & Processed == 0,
               extraction_rate = if_else(PositiveProd_ZeroProc == TRUE, Inf, extraction_rate),
               extraction_rate_trade = sum(Export) / sum(Export / extraction_rate),
               extraction_rate_trade = if_else(is.na(extraction_rate_trade), extraction_rate, extraction_rate_trade)) %>%
        ungroup() %>%
        group_by(APE_comm, GCAM_region_ID) %>%
        # Calculate lagged extraction_rate but replace NA with current rate (first period)
        mutate(extraction_rate_lag = lag(extraction_rate, default=extraction_rate[1])) %>%
        ungroup() %>%
        select(APE_comm, GCAM_region_ID, year, bal_import = extraction_rate_trade, bal_domestic_lag = extraction_rate_lag, bal_domestic_current = extraction_rate) %>%
        gather(bal_source, extraction_rate, bal_import, bal_domestic_lag, bal_domestic_current, factor_key = TRUE)
    }


    # Separate the SUA balance into domestic and imported balanced for sink_item
    # @description The function is used in Proc_primarize
    # @param DF_CURR_NEST Input supply-utilization accounting data frame with one tier of processing
    # @return SUA DF

    Get_ARMINGTON_BALANCE <- function(DF_CURR_NEST) {
      Import_Demand_Item <- factor(c("Food", "Feed", "Processed", "Other uses", "Seed", "Loss"), levels=All_Bal_element)

      DF_CURR_NEST %>%
        # Calculate imported consumption share
        # The assumption is that a portion of Import_Demand_Items was imported
        # so they need to be scaled by an international extraction rate
        # Note that stock variation is not included in import consumption to maintain stock balance
        # so additional adjustment may be needed
        filter(element == "Import" | element %in% Import_Demand_Item) %>%
        mutate(is_import = element == "Import") %>%
        spread(is_import, value, fill=0.0) %>%
        group_by(APE_comm, GCAM_region_ID, year, item_code) %>%
        summarize(import = sum(`TRUE`),
                  import_demand = sum(`FALSE`), .groups = "drop") %>%
        ungroup() %>%
        mutate(Import_Demand_Share = import / import_demand,
               # replace NA and inf
               Import_Demand_Share = if_else(is.finite(Import_Demand_Share), Import_Demand_Share, 0),
               # The share should be small than 1 though outlier regions may import for storage
               Import_Demand_Share = pmin(Import_Demand_Share, 1),
               residual = import - import_demand * Import_Demand_Share) %>%
        ungroup() %>%
        select(APE_comm, GCAM_region_ID, item_code, year, Import_Demand_Share, residual) %>%
        left_join(DF_CURR_NEST, ., by=c("APE_comm", "GCAM_region_ID", "item_code", "year")) %>%
        # when Import_Demand_Item consumption < Import they are used to share out Import consumptions
        # otherwise, Residuals is used for adjustments
        mutate(bal_import = case_when(element == "Import" ~ value,
                                      element %in% Import_Demand_Item ~ value * Import_Demand_Share,
                                      element == "Residuals" ~ residual,
                                      TRUE ~ 0),
               # Calculate domestic balance
               bal_domestic = value - bal_import) %>%
        select(-value, -Import_Demand_Share, -residual) %>%
        gather(bal_source, value, bal_import, bal_domestic, factor_key = TRUE) ->
        TradeBal_Data

      Regional_supply_elements <- factor(c("Opening stocks", "Production", "Import"), levels=All_Bal_element)
      Regional_demand_elements <- factor(c("Export", "Feed", "Food", "Loss", "Processed", "Seed", "Other uses", "Closing stocks"), levels=All_Bal_element)
      TradeBal_Data %>%
        mutate(is_supply = element %in% Regional_supply_elements,
               is_demand = element %in% Regional_demand_elements) %>%
        filter(is_supply | is_demand) %>%
        group_by(APE_comm, GCAM_region_ID, year, item_code, bal_source) %>%
        # Clean the bal items
        summarize(`Regional supply` = sum(value[is_supply]),
                  `Regional demand` = sum(value[is_demand]), .groups = "drop") %>%
        ungroup() %>%
        mutate(`Residuals` = `Regional supply` - `Regional demand`) %>%
        gather(element, value, `Regional supply`, `Regional demand`, `Residuals`) %>%
        mutate(element = factor(element, levels=All_Bal_element)) %>%
        bind_rows(TradeBal_Data %>% filter(!element %in% c("Regional supply", "Regional demand", "Residuals")), .)
    }


    # Separate the domestic SUA balance into current and lagged balanced for sink_item
    # @description The function is used in Proc_primarize
    # @param DF_CURR_NEST_TradeAdj Output from Get_ARMINGTON_BALANCE. Input supply-utilization accounting data frame with one tier of processing and
    # @param .SINK_ITEM Sink items or processed items in the processing
    # @return SUA DF

    Get_STOCK_BALANCE <- function(DF_CURR_NEST_TradeAdj) {
      Opening_Stock_Item <- factor(c("Food", "Feed", "Processed", "Other uses", "Seed", "Loss"), levels=All_Bal_element)

      get_bal_source_data <- function(data, bal_source_key) {
        data[data$bal_source == bal_source_key, "data", drop = TRUE][[1]]
      }

      DF_CURR_NEST_TradeAdj %>%
        tidyr::nest(data = -bal_source) ->
        StockCalcNested

      StockCalcNested %>%
        get_bal_source_data("bal_domestic") %>%
        filter(element == "Opening stocks" | element %in% Opening_Stock_Item) %>%
        mutate(is_opening = element == "Opening stocks") %>%
        spread(is_opening, value, fill=0.0) %>%
        group_by(APE_comm, GCAM_region_ID, year, item_code) %>%
        summarize(Ostock = sum(`TRUE`),
                  Ostock_demand = sum(`FALSE`), .groups = "drop") %>%
        ungroup() %>%
        mutate(Ostock_Demand_Share = Ostock / Ostock_demand,
               # The share should be small than 1
               # Other elements will be adjusted if not
               Ostock_Demand_Share = if_else(is.finite(Ostock_Demand_Share), Ostock_Demand_Share, 0),
               Ostock_Demand_Share = pmin(Ostock_Demand_Share, 1),
               residual = Ostock - Ostock_demand * Ostock_Demand_Share) %>%
        ungroup() %>%
        select(APE_comm, GCAM_region_ID, item_code, year, Ostock_Demand_Share, residual) %>%
        left_join(StockCalcNested %>% get_bal_source_data("bal_domestic"), ., by=c("APE_comm", "GCAM_region_ID", "item_code", "year")) %>%
        mutate(bal_domestic_lag = case_when(element == "Opening stocks" ~ value,
                                            element %in% Opening_Stock_Item ~ value * Ostock_Demand_Share,
                                            element == "Residuals" ~ residual,
                                            TRUE ~ 0),
               # Calculate domestic balance
               bal_domestic_current = value - bal_domestic_lag) %>%
        select(-value, -Ostock_Demand_Share, -residual) %>%
        gather(bal_source, value, bal_domestic_lag, bal_domestic_current, factor_key = TRUE) ->
        StockBal_Data

      Regional_supply_elements <- factor(c("Opening stocks", "Production", "Import"), levels=All_Bal_element)
      Regional_demand_elements <- factor(c("Export", "Feed", "Food", "Loss", "Processed", "Seed", "Other uses", "Closing stocks"), levels=All_Bal_element)
      Bal_types = c("bal_import", "bal_domestic_lag", "bal_domestic_current")
      Bal_types = factor(Bal_types, levels=Bal_types)
      StockBal_Data %>%
        complete(year = unique(StockBal_Data$year), nesting(GCAM_region_ID, item_code, element, APE_comm, bal_source), fill=list(value=0)) %>%
        mutate(is_supply = element %in% Regional_supply_elements,
               is_demand = element %in% Regional_demand_elements) %>%
        group_by(APE_comm, GCAM_region_ID, year, item_code, bal_source) %>%
        # Clean the bal items
        summarize(`Regional supply` = sum(value[is_supply]),
                  `Regional demand` = sum(value[is_demand]),
                  # using max to guard against missing Closing stocks row
                  `Stock Variation` = max(value[element == "Closing stocks"], 0) - max(value[element == "Opening stocks"], 0),
                  .groups = "drop") %>%
        ungroup() %>%
        mutate(`Residuals` = `Regional supply` - `Regional demand`) %>%
        gather(element, value, `Regional supply`, `Regional demand`, `Stock Variation`, `Residuals`) %>%
        mutate(element = factor(element, levels=All_Bal_element)) %>%
        bind_rows(StockBal_Data %>% filter(!element %in% c("Regional supply", "Regional demand", "Stock Variation", "Residuals")), .) %>%
        tidyr::nest(data = - bal_source) %>%
        mutate(bal_source = factor(bal_source, levels=Bal_types)) %>%
        bind_rows(StockCalcNested %>% filter(bal_source == "bal_import") %>% mutate(bal_source = factor(bal_source, levels=Bal_types))) %>%
        tidyr::unnest(c("data"))
    }


    # Primary equivalent aggregation
    # @param DF_ALL Input supply-utilization accounting data frame with all levels of data nested which need to be primarized
    # @return A supply-utilization accounting data frame with all levels processed and aggregated to GCAM_commodity

    Proc_primarize <- function(DF_ALL){
      MaxNest = max(DF_ALL$nest_level)
      MinNest = 1
      for(curr_nest in MaxNest:MinNest) {
        # get the current tier to process
        DF_ALL %>%
          filter(nest_level == curr_nest) %>%
          pull(data) %>%
          first() ->
          DF_CURR_NEST

        # Sink items or processed items in the processing
        curr_sink_items = unique(DF_CURR_NEST$item_code)
        Mapping_SUA_PrimaryEquivalent_ID %>%
          filter(sink_item_code %in% curr_sink_items) ->
          Curr_Sink_Mapping
        # Source items or primary items in the processing
        curr_source_items = unique(Curr_Sink_Mapping$source_item_code)
        Mapping_SUA_PrimaryEquivalent_ID %>%
          filter(source_item_code %in% curr_source_items) ->
          Curr_Source_Mapping

        # OUTPUT_SPECIFIC_EXTRACTION_RATE A data frame with item and output_specific_extraction_rate.
        #' # In some cases, prescale sink item SUA using output_specific_extraction_rate can improve the processing.
        #' # e.g., when coproduction shares are not fixed.
        if(nrow(OUTPUT_SPECIFIC_EXTRACTION_RATE %>% filter(item_code %in% curr_sink_items)) > 0) {
          ## a. Pre-scale sink item data when .OUTPUT_SPECIFIC_EXTRACTION_RATE is available ----
          DF_CURR_NEST %>%
            left_join(OUTPUT_SPECIFIC_EXTRACTION_RATE, by=c("item_code")) %>%
            replace_na(list(output_specific_extraction_rate = 1)) %>%
            mutate(value = value / output_specific_extraction_rate) %>%
            select(-output_specific_extraction_rate) ->
            DF_CURR_NEST
        }

        ## b. For the sink items of the tier, separate balance into domestic and imported ----
        # Note that the method here relies on Get_GROSS_EXTRACTION_RATE and Get_ARMINGTON_BALANCE
        DF_CURR_NEST %>%
          Get_ARMINGTON_BALANCE() %>%
          Get_STOCK_BALANCE() %>%
          # Get extraction rate for domestic and traded
          # Note that extraction rates are mean values across time
          # Note that regional extraction rate could be inf
          # It is likely due to data inconsistency, e.g., zero processed in source but positive sink
          # No adjustments were made since 1/inf become zero in the scaling process, preserving primary balance
          left_join(Get_GROSS_EXTRACTION_RATE(DF_CURR_NEST, DF_ALL), by=c("APE_comm", "GCAM_region_ID", "year", "bal_source")) %>%
          # Scale sink items to get source item equivalent
          mutate(value = value / extraction_rate) %>%
          select(-extraction_rate) ->
          .df1

        ## c. Aggregate sink_items are aggregated into "sink_item" ----
        # And production & processed are adjusted for primary aggregation
        # Bind source items as well
        DF_ALL %>%
          filter(nest_level <= curr_nest) %>%
          tidyr::unnest(c("data")) %>%
          filter(element == "Processed", item_code %in% curr_source_items) %>%
          select(-element) ->
          .df2

        .df2 %>%
          complete(GCAM_region_ID = GCAM_region_names$GCAM_region_ID, nesting(APE_comm, item_code, nest_level, year), fill=list(value=0)) %>%
          complete(.df2 %>% distinct(APE_comm, item_code, nest_level), nesting(GCAM_region_ID, year), fill=list(value=0)) ->
          .df2_1

        .df2_1 %>%
          # Use global value (year is specified now!)
          group_by(APE_comm, item_code, year) %>%
          mutate(value = sum(value)) %>%
          ungroup() %>%
          group_by(APE_comm, GCAM_region_ID, year) %>%
          mutate(share = value/ sum(value),
                 share = if_else(is.finite(share), share, dplyr::n()/sum(dplyr::n()))) %>%
          ungroup() %>%
          select(-value, source_item_code = item_code) ->
          source_share_global

        .df2_1 %>%
          group_by(APE_comm, item_code, year) %>%
          mutate(value = sum(value)) %>%
          ungroup() %>%
          group_by(APE_comm, GCAM_region_ID, year) %>%
          mutate(share = value/ sum(value),
                 share = if_else(is.finite(share), share, dplyr::n()/sum(dplyr::n()))) %>%
          ungroup() %>%
          select(-value, source_item_code = item_code) ->
          source_share_regional

        source_share_regional %>% mutate(bal_source = "bal_domestic_lag") %>%
          bind_rows(source_share_regional %>% mutate(bal_source = "bal_domestic_current")) %>%
          bind_rows(source_share_global %>% mutate(bal_source = "bal_import")) ->
          source_share

        ## d. Merge sink SUA into source items SUA  ----
        # Note that with multiple source items, sinks are aggregated into sources based on average processed shares across sources
        # Prepare data to calculate world average source share
        .df1 %>%
          left_join(source_share, by = c("bal_source", "GCAM_region_ID", "year", "APE_comm"))  %>%
          filter(!is.na(share)) %>%
          mutate(value = value * share,
                 item_code = source_item_code) %>%
          select(-share) %>%
          group_by(nest_level, APE_comm, GCAM_region_ID, year, item_code, element) %>%
          summarize(value = sum(value), .groups = "drop") %>%
          ungroup() %>%
          complete(element=All_Bal_element[All_Bal_element %in% c("Prodution", "Processed")], nesting(nest_level, APE_comm, GCAM_region_ID, year, item_code), fill=list(value=0)) %>%
          group_by(nest_level, APE_comm, GCAM_region_ID, year, item_code) %>%
          mutate(value = if_else(element == "Production" | element == "Processed", value - value[element == "Production"], value)) %>%
          ungroup() ->
          .df3

        # Bind source item and aggregated across source & sink items based on primary equivalent
        # Note we will bind and aggregate by nest, ultimately it seems unlikely nesting and provided
        # any performance boost, but certainly didn't hurt either.
        .df3 %>%
          tidyr::nest(data = -nest_level) ->
          df3_nested

        for(nest_i in df3_nested$nest_level) {
          bind_rows(
            DF_ALL[DF_ALL$nest_level == nest_i, "data", drop=TRUE][[1]],
            df3_nested[df3_nested$nest_level == nest_i, "data", drop=TRUE][[1]]) %>%
            group_by(APE_comm, GCAM_region_ID, year, item_code, element) %>%
            summarize(value = sum(value), .groups = "drop") %>%
            ungroup() ->
            AGG
          DF_ALL %>%
            filter(nest_level != nest_i) %>%
            bind_rows(tibble(nest_level = nest_i, data = list(AGG))) ->
            DF_ALL
        }
        # drop the processed tier as the data has now been aggregated and thus
        # no longer needed
        DF_ALL %>% filter(nest_level != curr_nest) ->
          DF_ALL
      }

      # Combine the remaining items by APE_comm
      DF_ALL %>%
        tidyr::unnest(c("data")) %>%
        group_by(GCAM_region_ID, APE_comm, element, year) %>%
        summarize(value = sum(value), .groups = "drop") %>%
        ungroup() %>%
        spread(element, value, fill = 0.0) %>%
        # Do a final balance cleaning
        mutate(`Regional supply` = `Opening stocks` + Production + `Import`,
               # ignore negative "processed" due to the above many-to-one processing above (should be small)
               Processed = if_else(Processed < 0, 0, Processed),
               Food = if_else(Food < 0, 0, Food),
               `Other uses` = if_else(`Other uses` < 0, 0, `Other uses`),
               `Regional demand` = `Export` + Feed + Food + Loss + Processed + Seed + `Other uses` +`Closing stocks`,
               Residuals = `Regional supply` -  `Regional demand`) %>%
        gather(element, value, -GCAM_region_ID, -APE_comm, -year) ->
        APE_AGG

      # Aggregate by GCAM_commodity
      # At this point we ditch the ID codes and factors as we return the data and
      # make it available for the rest of the original processing
      APE_AGG %>%
        left_join_error_no_match(Mapping_SUA_PrimaryEquivalent %>% select(GCAM_commodity, APE_comm) %>% distinct(),
                                 by = c("APE_comm")) %>%
        group_by(GCAM_region_ID, GCAM_commodity, element, year) %>%
        summarize(value = sum(value), .groups = "drop") %>%
        ungroup() %>%
        left_join_error_no_match(GCAM_region_names, by=c("GCAM_region_ID")) %>%
        mutate(element = as.character(element)) %>%
        select(region, year, GCAM_commodity, element, value) ->
        GCAM_APE_after2010

      return(GCAM_APE_after2010)
    }

    # 2.2. Execution: process data into APE ----


    ## Loop through all GCAM_commodity with available data ----

    FAO_SUA_Kt_2010to2019_R %>%
      # In both left_join here, APE_comm could be NA after the join and they are removed later
      left_join(Mapping_SUA_PrimaryEquivalent_ID %>%
                  select(APE_comm, item_code = sink_item_code, nest_level) %>% distinct(), by = c("item_code")) %>%
      left_join(Mapping_SUA_PrimaryEquivalent_ID %>%
                  select(APE_comm_source = APE_comm, item_code = source_item_code) %>% distinct(), by=c("item_code")) %>%
      # find SUA items which are truly not mapped to anything and filter them out
      mutate(APE_comm = if_else(is.na(APE_comm), APE_comm_source, APE_comm)) %>%
      select(-APE_comm_source) %>%
      filter(!is.na(APE_comm)) %>%
      # the remaining rows with NA nest_level are primary, we need to keep them
      # around for processing even though they don't need to be aggregated themselves
      # so we will give them a nest level of -1
      mutate(nest_level = if_else(is.na(nest_level), -1L, nest_level)) %>%
      # we will literally nest by nest level to avoid constant subseting
      # although we end up needed to unnest at times as well so ultimately,
      # it likely makes little difference in performance
      tidyr::nest(data = -nest_level) %>%
      # we are now ready to recursively primarize APE commodities then aggregate
      # to GCAM commodities
      Proc_primarize() ->
      GCAM_APE_after2010

    rm(FAO_SUA_Kt_2010to2019_R)

    ## Done Section2 ----
    #****************************----

    # Section3 [1970-2009] Food balance sheet (original) aggregation to GCAM regions and commodities ----

    # 3.1. Helper functions ----

    # GROSS_TRADE_ADJUST() moved to xfaostat_helper_func.R


    # 3.2. Execution ----
    ## a. FBSH_CB aggregate to GCAM commodity and region----

    GCAMFAOSTAT_FBSH_CB %>%
      gather_years() %>%
      filter(year < Min_SUA_Year) %>%
      filter(!is.na(value)) ->
      FBSH_CB

    # assert mapping is good
    assertthat::assert_that(
      Mapping_item_FBS_GCAM %>% filter(!is.na(GCAM_commodity)) %>%
        distinct(item_code) %>% pull() %in%
        c(FBSH_CB %>% distinct(item_code) %>% pull) %>% all)

    Mapping_item_FBS_GCAM %>%
      select(item_code, GCAM_commodity)%>%
      filter(!is.na(GCAM_commodity)) %>%
      # Using inner_join since not all items in FBSH_CB are used; left_join would work the same
      inner_join(FBSH_CB, by = "item_code") %>%
      left_join_error_no_match(AGLU_ctry %>% distinct(area_code = FAO_country_code, iso), by = c("area_code")) %>%
      left_join_error_no_match(iso_GCAM_regID %>% select(iso, GCAM_region_ID), by = "iso") %>%
      left_join_error_no_match(GCAM_region_names, by = "GCAM_region_ID") %>%
      dplyr::group_by_at(vars(area = region, year, GCAM_commodity, element)) %>%
      summarise(value = sum(value), .groups = "drop") %>%
      # complete element
      complete(nesting(area, year, GCAM_commodity), element,
               fill = list(value = 0)) ->
      FBSH_CB_GCAM


    ## b. Get primary production in GCAM region and sector ----

    GCAMFAOSTAT_NonFodderProdArea %>%
      gather_years() %>%
      filter(year < Min_SUA_Year) %>%
      filter(!is.na(value), element == "Production") %>%
      inner_join(
        Mapping_SUA_PrimaryEquivalent %>% filter(source_primary == T) %>%
          distinct(GCAM_commodity, item = source_item) %>%
          left_join_error_no_match(SUA_item_code_map, by = "item") %>% select(-item),
        by = "item_code") %>%
      left_join_error_no_match(AGLU_ctry %>% distinct(area_code = FAO_country_code, iso), by = c("area_code")) %>%
      left_join_error_no_match(iso_GCAM_regID %>% select(iso, GCAM_region_ID), by = "iso") %>%
      left_join_error_no_match(GCAM_region_names, by = "GCAM_region_ID") %>%
      dplyr::group_by_at(vars(area = region, year, GCAM_commodity, element)) %>%
      summarise(value = sum(value), .groups = "drop") ->
      QCL_PROD_GCAM

    ## c. QCL_PROD_GCAM and FBSH_CB_GCAM: merge, scale, and connect----
    # Connect SUA (FBSH_CB) to primary production (QCL_PROD_GCAM)
    # Primary production could be different due to aggregation or inconsistency

    QCL_PROD_GCAM %>%
      filter(year >= min(unique(FBSH_CB_GCAM$year))) %>%
      # Complete elements in QCL_PROD
      # also GCAM_commodity because no pork production in Pakistan
      complete(area, year, GCAM_commodity,
               element = unique(FBSH_CB_GCAM$element), fill = list(value = 0)) %>%
      left_join_error_no_match(
        FBSH_CB_GCAM %>%
          # complete element to add zero productions
          complete(area, year, GCAM_commodity, element, fill = list(value = 0)) %>%
          rename(FBSH_CB = value),
        by = c("area", "year", "GCAM_commodity", "element")
      ) %>%
      # mapping
      group_by(area, GCAM_commodity, year) %>%
      # When production in FBSH_CB > primary production (QCL_PROD_GCAM), adjust processed
      # to ensure production <= primary production when processed is enough; (will scale later)
      # calculate Prod_diff which is the diff in production b/t the two data sets
      mutate(Prod_diff = FBSH_CB[element == "Production"] - value[element == "Production"] ) %>%
      # adjust processed when prod_diff > 0 by canceling off production and processed
      mutate(Prod_diff = if_else(Prod_diff > 0 & element %in% c("Production", "Processed"), Prod_diff, 0),
             Processed = if_else(Prod_diff > 0 & element %in% c("Production", "Processed"),
                                 FBSH_CB[element == "Processed"], 0),
             FBSH_CB = FBSH_CB - pmin(Prod_diff, Processed),
             # When production in FBSH_CB = 0 set to production in QCL so scaling will be consistent
             FBSH_CB = if_else(FBSH_CB[element == "Production"] == 0 & element == "Production", value, FBSH_CB),
             # After the above adjustments, re-scale SUA to match production in value
             value = FBSH_CB * value[element == "Production"]/FBSH_CB[element == "Production"],
             # fix NA
             value = if_else(!is.finite(value), FBSH_CB, value)) %>%
      ungroup() %>%
      select(area, GCAM_commodity, element, year, value) %>%
      # adjust gross trade
      GROSS_TRADE_ADJUST(.MIN_TRADE_PROD_RATIO = 0.001,
                         .Reg_VAR = "area",
                         .GROUP_VAR = c("GCAM_commodity", "year")) %>%
      spread(element, value) %>%
      # Note that stock variation here was  = opening - ending
      # reversed here so the variation is a demand
      mutate(`Stock Variation` = - `Stock Variation`,
             `Regional supply` = Production + `Import`,
             `Regional demand` = `Export` + Feed + Food + Loss + Processed + Seed + `Other uses` + `Stock Variation`,
             Residuals = `Regional supply` -  `Regional demand`) %>%
      tidyr::gather(element, value, -area, -GCAM_commodity, -year) %>%
      ungroup() %>%
      rename(region = area) ->
      GCAM_APE_before2010

    rm(FBSH_CB, FBSH_CB_GCAM)

    ## Done Section3 ----
    #****************************----

    # Section4 [1970-2019] GCAM_APE SUA ----

    # 4.1. Helper functions ----
    Check_Balance_SUA <- function(.DF){
      NULL -> element -> GCAM_commodity -> Import -> Export -> Production -> Food ->
        Feed -> `Other uses` -> `Regional supply` -> `Regional demand` -> bal ->
        region

      assertthat::assert_that(all(c("element") %in% names(.DF)))
      assertthat::assert_that(all(c("Import", "Export", "Production",
                                    "Food", "Feed", "Other uses") %in%
                                    c(.DF %>% distinct(element) %>% pull)))
      # 0. Check NA
      if (.DF %>% filter(is.na(value)) %>% nrow() > 0) {
        warning("NA values in SUA Balance")
      }


      # 1. Positive value except stock variation and residues
      if (isFALSE(.DF %>% filter(!element %in% c("Stock Variation", "Other uses")) %>%
                 summarise(min = min(value, na.rm = T)) %>% pull(min) >= -0.001)) {
        warning("Negative values in key elements (not including stock variation and other uses)")
      }

      # 2. Trade balance in all year and items
      if (isFALSE(.DF %>% filter(element %in% c("Import", "Export")) %>%
                 group_by(year, GCAM_commodity, element) %>%
                 summarise(value = sum(value), .groups = "drop") %>%
                 spread(element, value) %>% filter(abs(Import - Export) > 0.0001) %>% nrow() == 0)) {
        warning("Gross trade imbalance")
      }

      # 3. SUA balance check
      if (isFALSE(.DF %>%
                 spread(element, value) %>%
                 mutate(`Regional supply` = Production + `Import`,
                        `Regional demand` = `Export` + Feed + Food + `Stock Variation` + Loss + `Other uses`,
                        bal = abs(`Regional supply` -  `Regional demand`)) %>%
                 filter(bal > 0.0001) %>% nrow() == 0)) {
        warning("Regional supply != Regional demand + Residuals")
      }

      # 4. Balanced in all dimensions
      .DF %>% filter(year < 2010) -> .DF1
      assertthat::assert_that(.DF1 %>% nrow() ==
                                .DF1 %>% distinct(year) %>% nrow *
                                .DF1 %>% distinct(GCAM_commodity) %>% nrow *
                                .DF1 %>% distinct(element) %>% nrow *
                                .DF1 %>% distinct(region) %>% nrow)

      .DF %>% filter(year >= 2010) -> .DF1
      assertthat::assert_that(.DF1 %>% nrow() ==
                                .DF1 %>% distinct(year) %>% nrow *
                                .DF1 %>% distinct(GCAM_commodity) %>% nrow *
                                .DF1 %>% distinct(element) %>% nrow *
                                .DF1 %>% distinct(region) %>% nrow)

    }


    # 4.2. Connect and bind data from two periods ----

    GCAM_AgLU_SUA_APE_1973_2019 <-
      GCAM_APE_before2010 %>%
      bind_rows(GCAM_APE_after2010) %>%
      mutate(unit = "1000 tonnes") %>%
      # clean and aggregate elements not using
      filter(!element %in% c("Regional demand", "Regional supply")) %>%
      mutate(element = replace(element,
                               element %in% c("Processed",
                                              "Seed", "Residuals"),
                               "Other uses")) %>%
      dplyr::group_by_at(dplyr::vars(-value)) %>%
      summarise(value = sum(value), .groups = "drop")

    ## Check balance
    GCAM_AgLU_SUA_APE_1973_2019 %>% Check_Balance_SUA

    rm(GCAM_APE_before2010, GCAM_APE_after2010)


    ## Done Section4 ----
    #****************************----

    # Section5 [1970-2019] Connect production and area data ----

    # This section gets crop and livestock production before aggregation (FAO region and items)
    # For both before 2010 and after 2010
    # They are also aggregated to GCAM region and commodities to assert consistency
    # The processing includes all crops (including fodder crops) and livestock items

    # 5.1. Get all mapping straight ----

    Primary_Item_CROP <-
      FAO_ag_items_PRODSTAT %>%
        select(item, item_code, GCAM_commodity, GCAM_subsector) %>%
        filter(!is.na(item), !is.na(GCAM_commodity)) %>%
        # Fodder grass has a duplicate as it mapped to different GTAP crops
        distinct %>%
        mutate(CropMeat = if_else(GCAM_commodity %in% c("FodderGrass", "FodderHerb"),
                                  "Crop_Fodder", "Crop_NonFodder"))
    assertthat::assert_that(
      all(Primary_Item_CROP %>% filter(CropMeat == "Crop_NonFodder") %>%  pull(item_code) %in%
        c(Mapping_SUA_PrimaryEquivalent %>%
            filter(source_primary == T) %>%
            distinct(item = source_item) %>%
            left_join_error_no_match(SUA_item_code_map, by = "item") %>% pull(item_code) )
        ),
      msg = "Inconsistent mapping of primary crops between FAO_ag_items_PRODSTAT and Mapping_SUA_PrimaryEquivalent" )

    Primary_Item_MEAT <-
      Mapping_SUA_PrimaryEquivalent %>%
      # animal meat Eq since they are included as primary production after 2010
      filter(source_primary == T | grepl("MeatEq", APE_comm)) %>%
      distinct(GCAM_commodity, item = source_item) %>%
      filter(GCAM_commodity %in%
               c(FAO_an_items_PRODSTAT %>%
                   filter(!is.na(GCAM_commodity)) %>%
                   distinct(GCAM_commodity) %>% pull))%>%
      left_join_error_no_match(SUA_item_code_map, by = "item") %>%
      mutate(CropMeat = "Meat")

    # 5.2. Get primary production for all ----
    # Connecting, mapping, arrange, and assertion

    ## Bind production and area data for both fodder and nonfodder ----
    FAO_AgProd_Kt_Area_Kha <-
      GCAMFAOSTAT_FodderProdArea%>%
      mutate(item_set = "QCL_COMM_CROP_PRIMARY_FODDER") %>%
      bind_rows(GCAMFAOSTAT_NonFodderProdArea) %>%
      gather_years() %>%
      filter(!is.na(value))

    # Assert yield no inf.
    assertthat::assert_that(
      # only safeguard here as data was cleaned and area and prod are matched
      FAO_AgProd_Kt_Area_Kha %>%
        # filter only primary crop items (all crops with area)
        filter(item_set %in% c("QCL_COMM_CROP_PRIMARY",
                               "QCL_COMM_CROP_PRIMARY_FODDER")) %>%
        select(area_code, item_code, year, element, value) %>%
        spread(element, value) %>%
        filter(is.infinite(Production / `Area harvested`|
                             is.infinite(`Area harvested`/Production)) ) %>%
        nrow == 0,
      msg = "Check region/item for prod > 0 & area = 0 or prod = 0 & area > 0" )

    # Assert primary production in two sources area consistent
    assertthat::assert_that(
      FAO_SUA_Kt_2010to2019 %>% filter(element == "Production") %>%
        inner_join(FAO_AgProd_Kt_Area_Kha %>%
                     filter(item_set != "QCL_COMM_OTHERPROC") %>%
                     filter(element == "Production") %>% rename(value1 = value),
                   by = c("area_code", "item_code", "element", "year")) %>%
        mutate(diff = abs(value1 - value)) %>%
        filter(diff > 0.0001) %>% nrow() == 0,
      msg = "Primary production in SUA (FAO_SUA_Kt_2010to2019) and
      QCL (FAO_AgProd_Kt_Area_Kha) are inconsistent "
    )

    ## a. All production ----
    # Meat production is more than (QCL)FAO_AgProd_Kt_Area_Kha after 2010
    # Production in FAO_AgProd_Kt_Area_Kha before 2010 was used
    FAO_AgProd_Kt_Area_Kha %>%
      filter(element == "Production") %>%
      filter(year < Min_SUA_Year) %>%
      select(c(names(FAO_SUA_Kt_2010to2019), "item")) %>%
      bind_rows(
        # For after 2010
        # Note that not all meat items came from QCL_PROD (unlike primary crops)
        # E.g., meat Eq, offals (livers chicken), etc. were from derivation or SCL
        # But all items should exist in Bal_new_all
        # And Bal_new_all is identical to QCL_PROD for primary productions
        FAO_SUA_Kt_2010to2019 %>%
          filter(element == "Production") %>%
          # ensure we at least have a complete series across time otherwise it may
          # throw off moving avg calculations
          complete(area_code = Area_Region_Map$area_code, year = pull(., year) %>% unique(), nesting(item_code, element), fill=list(value=0)) %>%
          left_join_error_no_match(SUA_item_code_map, by = c("item_code"))
        ) %>%
      bind_rows(
        # bind fodder crops for after 2010
        FAO_AgProd_Kt_Area_Kha %>%
          filter(item_set == "QCL_COMM_CROP_PRIMARY_FODDER",
                 element == "Production") %>%
          filter(year >= Min_SUA_Year) %>%
          select(c(names(FAO_SUA_Kt_2010to2019), "item"))
      ) %>%
      # Inner join works as filter here
      # Keep subsector info for crops
      inner_join(Primary_Item_CROP %>%
                   bind_rows(Primary_Item_MEAT %>%
                               mutate(GCAM_subsector = GCAM_commodity)) %>%
                   select(-item),
                 by = "item_code") %>%
      # add in iso and gcam regions ID
      left_join_error_no_match(Area_Region_Map, by = "area_code") ->
      FAO_AgProd_Kt_All

    FAO_AgProd_Kt_All %>%
      dplyr::group_by_at(vars(region, year, GCAM_commodity, element, CropMeat)) %>%
      summarise(value = sum(value), .groups = "drop") ->
      QCL_PROD_GCAM

    FAO_AgProd_Kt_All %>%
      select(-region) ->
      FAO_AgProd_Kt_All

    assertthat::assert_that(
      GCAM_AgLU_SUA_APE_1973_2019 %>%
        filter(element == "Production") %>%
        left_join_error_no_match(
          QCL_PROD_GCAM %>% filter(CropMeat != "Crop_Fodder") %>%
            select(-CropMeat) %>%
            rename(value1 = value) %>%
            complete(nesting(region, year, element), GCAM_commodity, fill = list(value1 = 0)),
          by = c("region", "GCAM_commodity", "year", "element")) %>%
        mutate(diff = abs(value1 - value)) %>%
        filter(diff > 0.0001) %>% nrow() == 0,
        msg = "Primary production from two sources
              (GCAM_AgLU_SUA_APE_1973_2019 and FAO_AgProd_Kt_Area_Kha) are inconsistent." )

    ## b. All area harvested ----

    assertthat::assert_that(
      all(Primary_Item_CROP %>% pull(item_code) %in%
            c(FAO_AgProd_Kt_Area_Kha %>%
                filter(item_set %in% c("QCL_COMM_CROP_PRIMARY",
                                       "QCL_COMM_CROP_PRIMARY_FODDER")) %>%
                pull(item_code)) ),
      msg =  "Not all required primary crop items included in FAO_AgProd_Kt_Area_Kha" )

    FAO_AgProd_Kt_Area_Kha %>%
      filter(element == "Area harvested") %>%
      select(c(names(FAO_SUA_Kt_2010to2019), "item")) %>%
      # Keep subsector info for crops
      inner_join(Primary_Item_CROP %>% select(-item), by = "item_code") %>%
      # add in iso and gcam regions ID
      left_join_error_no_match(Area_Region_Map %>% select(-region), by = "area_code") ->
      FAO_AgArea_Kha_All

    #****************************----
    #Section6 Connect food items and macronutrient rates ----

    # 6.1 Separate FAO food items into GCAM food items and NEC for macronutrient ----
    # GCAM included most of the food items
    # All food item with available macronutrient info from FAOSTAT are included

    # a. Get all GCAM SUA items from the mapping by binding both source and sink items
    # about 486 items (out of 530) used in GCAM

    Mapping_SUA_PrimaryEquivalent %>%
      select(GCAM_commodity, item = source_item) %>%
      bind_rows(Mapping_SUA_PrimaryEquivalent %>%
                  select(GCAM_commodity, item = sink_item)) %>%
      distinct() %>%
      left_join_error_no_match(SUA_item_code_map, by = "item") ->
      SUA_Items_GCAM

    assertthat::assert_that(
      SUA_Items_GCAM %>% distinct(item_code) %>% nrow() == SUA_Items_GCAM %>% nrow(),
      msg = "Check duplicates in Mapping_SUA_PrimaryEquivalent SUA items"
    )

    # highly processed products or other products are not included in GCAM
    # (e.g., wine, infant food, or other nonfood items etc.)

    SUA_item_code_map %>%
      filter(!item_code %in% unique(SUA_Items_GCAM$item_code)) -> SUA_Items_NonGCAM

    # b. There are 426 FAO food items, all included in FAO_SUA_Kt_2010to2019 (530 items)
    # SUA_Items_Food includes both GCAM and NonGCAM(NEC)
    SUA_item_code_map %>%
      filter(item_code %in% unique(GCAMFAOSTAT_MacroNutrientRate$item_code)) %>%
      # NA expected here
      left_join(SUA_Items_GCAM %>% select(-item), by = "item_code") %>%
      # For NA GCAM_commodity: not elsewhere classified (NEC)
      # So we would know % of food calories not included in GCAM commodities
      mutate(GCAM_commodity = if_else(is.na(GCAM_commodity), "NEC", GCAM_commodity)) ->
      SUA_Items_Food


    # 6.2 Get macronutrient values ----

    ### a. Get world average macronutrient ----
    # For filling in missing values

    GCAMFAOSTAT_MacroNutrientRate %>%
      tidyr::gather(macronutrient, macronutrient_value, calperg:proteinperc) %>%
      group_by(item, item_code, macronutrient) %>%
      summarise(macronutrient_value_World = mean(macronutrient_value), .groups = "drop") %>%
      ungroup() ->
      SUA_food_macronutrient_rate_World


    ### b. Calculate SUA food Calories consumption by joining macronutrient rates and SUA food ----

    FAO_SUA_Kt_2010to2019 %>%
      filter(element == "Food", item_code %in% SUA_Items_Food$item_code) %>%
      # ensure we at least have a complete series across time otherwise it may
      # throw off moving avg calculations
      complete(area_code = Area_Region_Map$area_code, year = pull(., year) %>% unique(), nesting(item_code, element), fill=list(value=0)) %>%
      rename(Food_Kt = value) %>%
      select(-element) %>%
      left_join_error_no_match(SUA_Items_Food, by = c("item_code")) %>%
      repeat_add_columns(
        tibble(macronutrient = c("calperg", "fatperc", "proteinperc"))) %>%
      left_join(
        GCAMFAOSTAT_MacroNutrientRate %>%
          select(-item) %>%
          tidyr::gather(macronutrient, macronutrient_value, calperg:proteinperc),
        by = c("area_code", "item_code", "macronutrient")
      ) %>%
      left_join_error_no_match(SUA_food_macronutrient_rate_World %>% select(-item),
                               by = c("item_code", "macronutrient")) %>%
      mutate(macronutrient_value = if_else(is.na(macronutrient_value),
                                           macronutrient_value_World,
                                           macronutrient_value),
             # calculate total Cal, protein and fat in food
             # value was in 1000 ton or 10^ 9 g
             value = macronutrient_value * Food_Kt,
             value = if_else(macronutrient %in% c("fatperc", "proteinperc"),
                             value / 100 /1000, value)) %>% # unit from perc to Mt
      select(-macronutrient_value, -macronutrient_value_World, -Food_Kt) %>%
      # rename element with units
      mutate(macronutrient = case_when(
        macronutrient == "calperg" ~ "MKcal",
        macronutrient == "fatperc" ~ "MtFat",
        macronutrient == "proteinperc" ~ "MtProtein" )) %>%
      left_join_error_no_match(Area_Region_Map %>% select(-region), by = "area_code") ->
      FAO_Food_Macronutrient_All_2010_2019

    ### c. Get the max values of macronutrient conversion rate (per GCAM_commodity) ----
    # This will be used later as an upper bound to improve the data
    GCAMFAOSTAT_MacroNutrientRate %>%
      tidyr::gather(macronutrient, macronutrient_value, calperg:proteinperc) %>%
      left_join_error_no_match(SUA_Items_Food %>% select(-item),
                               by = c("item_code")) %>%
      group_by(GCAM_commodity, macronutrient) %>%
      summarise(max_macronutrient_value = max(macronutrient_value), .groups = "drop") ->
      FAO_Food_MacronutrientRate_2010_2019_MaxValue


    #****************************----
    # Produce outputs ----
    #*******************************

    GCAM_AgLU_SUA_APE_1973_2019 %>%
      add_title("GCAM_AgLU_SUA_APE_1973_2019") %>%
      add_units("kton") %>%
      add_comments("Supply utilization balance for GCAM commodities and regions in primary equivalent") %>%
      add_precursors("aglu/AGLU_ctry",
                     "common/iso_GCAM_regID",
                     "common/GCAM_region_names",
                     "aglu/FAO/GCAMFAOSTAT_SUA",
                     "aglu/FAO/GCAMFAOSTAT_BiTrade",
                     "aglu/FAO/Mapping_SUA_PrimaryEquivalent",
                     "aglu/FAO/SUA_item_code_map",
                     "aglu/FAO/GCAMFAOSTAT_NonFodderProdArea",
                     "aglu/FAO/GCAMFAOSTAT_FBSH_CB",
                     "aglu/FAO/Mapping_item_FBS_GCAM") ->
      GCAM_AgLU_SUA_APE_1973_2019

    FAO_AgProd_Kt_All %>%
      add_title("FAO_AgProd_Kt_All") %>%
      add_units("1000 tonnes") %>%
      add_comments("Supply utilization balance for GCAM commodities and regions in primary equivalent") %>%
      add_precursors("aglu/AGLU_ctry",
                     "common/iso_GCAM_regID",
                     "aglu/FAO/FAO_ag_items_PRODSTAT",
                     "aglu/FAO/FAO_an_items_PRODSTAT",
                     "aglu/FAO/Mapping_SUA_PrimaryEquivalent",
                     "aglu/FAO/GCAMFAOSTAT_FodderProdArea",
                     "aglu/FAO/GCAMFAOSTAT_NonFodderProdArea") ->
      FAO_AgProd_Kt_All

    FAO_AgArea_Kha_All %>%
      add_title("FAO_AgArea_Kha_All") %>%
      add_units("1000 ha") %>%
      add_comments("Harvested area") %>%
      add_precursors("aglu/AGLU_ctry",
                     "common/iso_GCAM_regID",
                     "aglu/FAO/FAO_ag_items_PRODSTAT",
                     "aglu/FAO/FAO_an_items_PRODSTAT",
                     "aglu/FAO/Mapping_SUA_PrimaryEquivalent",
                     "aglu/FAO/GCAMFAOSTAT_FodderProdArea",
                     "aglu/FAO/GCAMFAOSTAT_NonFodderProdArea") ->
      FAO_AgArea_Kha_All

    FAO_Food_Macronutrient_All_2010_2019 %>%
      add_title("GCAM_AgLU_SUA_APE_1973_2019") %>%
      add_units("MKcal, MtFat, MtProtein") %>%
      add_comments("Macronutrient consumption values connected to food consumption in GCAM_AgLU_SUA_APE_1973_2019") %>%
      add_precursors("aglu/AGLU_ctry",
                     "common/iso_GCAM_regID",
                     "aglu/FAO/GCAMFAOSTAT_SUA",
                     "aglu/FAO/GCAMFAOSTAT_MacroNutrientRate",
                     "aglu/FAO/Mapping_SUA_PrimaryEquivalent") ->
      FAO_Food_Macronutrient_All_2010_2019

    FAO_Food_MacronutrientRate_2010_2019_MaxValue %>%
      add_title("FAO_Food_MacronutrientRate_2010_2019_MaxValue") %>%
      add_units("cal per g, fat perc. , protein perc.") %>%
      add_comments("The max value of macronutrient conversion rate across region, year, and SUA items (per GCAM_commodity") %>%
      add_precursors("aglu/AGLU_ctry",
                     "common/iso_GCAM_regID",
                     "aglu/FAO/GCAMFAOSTAT_SUA",
                     "aglu/FAO/GCAMFAOSTAT_MacroNutrientRate",
                     "aglu/FAO/Mapping_SUA_PrimaryEquivalent") ->
      FAO_Food_MacronutrientRate_2010_2019_MaxValue

    return_data(MODULE_OUTPUTS)


  } else {
    stop("Unknown command")
  }
}
